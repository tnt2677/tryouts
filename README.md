# Tryouts

New things to learn and explore !!

- [Tryouts](#tryouts)
  - [Basic Markdown syntax](#basic-markdown-syntax)
  - [CPP Lambda tutorials](#cpp-lambda-tutorials)
    - [How Compiler generates](#how-compiler-generates)

## Basic Markdown syntax

[`Basic Markdown Guide`](https://www.markdownguide.org/basic-syntax/)

## CPP Lambda tutorials

[`Lambda vs std::function`](
  https://stackoverflow.com/questions/20353210/usage-and-syntax-of-stdfunction)
[`Lambda C++11 snippets`](https://www.bogotobogo.com/cplusplus/C11/C11_lambda_functions_expressions.php)

Lambda's introduced in C++11 are used to create anonymous functions, in layman
terms are analogous to Function pointers of C, these allow inline declaration
of functions which can be passed around as parameters to other functions,
which can then use our newly defined function (read Lambda) to dynamically
decide on actions to perform.

This is new syntax in C++11 to add the ability to write simple function-like
objects (Sounds very similar to functors!!), objects that can be invoked
with ().

Such objects can be type erased and stored in a `std::function` at the cost of
some run time overhead.

`[](){ code }` in particular is a really simple lambda. It corresponds to this:

```cpp
struct some_anonymous_type {
  //struct's constructor
  some_anonymous_type() {}
  void operator()const{
    code
  }
};
```

### How Compiler generates

An actual class like the above is generated by the compiler, with an
implementation defined unique name (often including symbols that no
user-defined type can contain) (I do not know if it is possible that you can
follow the standard without inventing such a class, but every compiler I know
of actually creates the class) - verify.

The full lambda syntax looks like:

```cpp
    [ capture_list ]( argument_list )
    -> return_type optional_mutable
    {
      code
    }
```

but many parts can be omitted or left empty.

1. Capture_list corresponds to : Constructor's argument of the resulting
    anonymous type & its member variables.
2. Argument_list to : arguments of the operator(),
3. Return type to : return type.

 When instance is created with the capture_list, Lambda instance's constructor
 is invoked.

```cpp
[ capture_list ]( argument_list ) -> return_type { code }
```

basically becomes :

```cpp
struct some_anonymous_type {
  // capture_list turned into member variables
  some_anonymous_type( /* capture_list turned into arguments */ ):
    /* member variables initialized */
  {}
  return_type operator()( argument_list ) const {
    code
  }
};
```
